{"version":3,"sources":["AllTheFuckingState.tsx","utils/PromiseAllChunk.ts","utils/CoolCache.ts","utils/pokeGetter.ts","PokeGetterContext.tsx","utils/BetterSelect.tsx","Board.tsx","LandingPage.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["initialState","users","player","opponent","board","name","columns","game","id","pokedex","generation","pokemon","reducer","state","action","type","payload","initialContext","dispatch","AllTheFuckingStateCtx","createContext","AllTheFuckingStateProvider","children","useReducer","value","Provider","PromiseAllSettledChunk","ps","a","chunkSize","pchunks","cur","length","chunk","slice","push","allRes","Promise","allSettled","res","concat","CoolCache","key","handler","this","lookupVal","mkKey","localVal","localStorage","getItem","parsed","JSON","parse","setItem","stringify","PokemonCache","PokeAPI","PokemonSpecies","resolve","species","defaultForm","varieties","find","variety","is_default","Pokemon","nationalDexNumber","artworkUrl","sprites","front_default","names","reduce","acc","language","GameCache","title","Version","VerionGroup","version_group","group","pokedexes","map","dex","PokedexCache","Pokedex","pokemonEntries","pokemon_entries","entry","pokemon_species","num","entry_number","sort","b","getAllGenerations","lang","Generaition","listAll","genList","genRequests","results","gen","all","genInfoDump","gens","forEach","genName","getPokemonByPokedex","memo","dexName","get","pokemonPromises","poke","pokemonCacheResults","pokemonAccepted","filter","r","status","pokemonCached","getPokemonByGeneration","generationId","currentGen","genPromises","pokePromises","p","getAllGames","gameResources","gamePromises","cachedGames","filtered","cache","getPokedexByGame","gameName","dexNames","dexPromises","cachedDexes","basePokedexes","PokeGetter","initialGetter","PokeGetterContext","PokeGetterProvider","props","useState","getter","setGetter","useEffect","BetterSelect","stuffLookup","Map","data","d","set","getValue","FormControl","fullWidth","InputLabel","htmlFor","label","Select","onChange","event","target","trueValue","MenuItem","getDisplayValue","getKeyValue","useCellStyles","makeStyles","root","display","background","variant","teal","red","blueGrey","image","Cell","onClick","styles","className","useBoardStyles","gridTemplateColumns","listStyle","padding","Board","items","renderCell","item","useBoardContainerStyles","width","height","overflow","BoardContainer","Box","useCreateStyles","margin","marginTop","CreateUser","useContext","setState","Container","fixed","maxWidth","Paper","onSubmit","preventDefault","TextField","Button","BoardSetup","games","setGames","dexes","setDexes","fetch","Grid","container","xs","component","Input","Number","src","alt","LandingPage","App","basename","exact","path","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","StylesProvider","CssBaseline","document","getElementById"],"mappings":"kNAsCMA,EAA6B,CACjCC,MAAO,CACLC,OAAQ,KACRC,SAAU,MAEZC,MAAO,CACLC,KAAM,GACNC,QAAS,GACTC,KAAM,CACJC,GAAI,MACJH,KAAM,MACNI,QAAS,IAEXC,WAAY,CACVF,GAAI,EACJH,KAAM,gBAERI,QAAS,CACPD,GAAI,QACJH,KAAM,QACNM,QAAS,IAEXA,QAAS,KA0Db,SAASC,EAAQC,EAAqBC,GACpC,OAAQA,EAAOC,MACb,IAAK,YACH,OAAO,2BACFF,GADL,IAEEZ,MAAM,2BACDY,EAAMZ,OADN,IAEHC,OAAQ,CACNG,KAAMS,EAAOE,QAAQX,UAK7B,IAAK,kBACH,OAAO,2BACFQ,GADL,IAEET,MAAM,2BACDS,EAAMT,OADN,IAEHE,QAASQ,EAAOE,QAAQV,YAI9B,IAAK,eACH,OAAO,2BACFO,GADL,IAEET,MAAM,2BACDS,EAAMT,OADN,IAEHC,KAAMS,EAAOE,QAAQX,SAI3B,IAAK,qBACH,OAAO,2BACFQ,GADL,IAEET,MAAM,2BACDS,EAAMT,OADN,IAEHM,WAAW,eACNI,EAAOE,aAKlB,IAAK,eACH,OAAO,2BACFH,GADL,IAEET,MAAM,2BACDS,EAAMT,OADN,IAEHG,KAAK,eACAO,EAAOE,aAKlB,IAAK,kBACH,OAAO,2BACFH,GADL,IAEET,MAAM,2BACDS,EAAMT,OADN,IAEHO,QAAQ,YAAKG,EAAOE,aAI1B,IAAK,kBACH,OAAO,2BACFH,GADL,IAEET,MAAM,2BACDS,EAAMT,OADN,IAEHK,QAAQ,eACHK,EAAOE,aAKlB,QACE,OAAOH,GAab,IAAMI,EAAiC,CACrCJ,MAAOb,EACPkB,SAFqC,cAK1BC,EACXC,wBAA8BH,GAMzB,SAASI,EAAT,GAA0D,IAApBC,EAAmB,EAAnBA,SAC3C,EAA0BC,qBAAWX,EAASZ,GAA9C,mBACMwB,EAAwB,CAC5BX,MAFF,KAGEK,SAHF,MAKA,OACE,cAACC,EAAsBM,SAAvB,CAAgCD,MAAOA,EAAvC,SACGF,I,8EC1NA,SAAeI,EAAtB,kC,4CAAO,WACLC,GADK,2CAAAC,EAAA,sDAOL,IALAC,EAFK,+BAEe,GAGdC,EAA0B,GAC5BC,EAAM,EACHA,EAAMJ,EAAGK,QACRC,EAAQN,EAAGO,MAAMH,EAAKA,EAAMF,GAClCC,EAAQK,KAAKF,GACbF,GAAOF,EAILO,EAAoC,GAdnC,MAeeN,EAff,gDAeMG,EAfN,eAgBeI,QAAQC,WAAWL,GAhBlC,QAgBGM,EAhBH,OAiBHH,EAASA,EAAOI,OAAOD,GAjBpB,4DAoBEH,GApBF,6C,sBCUA,IAAMK,EAAb,WAYE,WAAYC,EAAaC,GAA0B,yBAR3CD,SAQ0C,OAF1CC,aAE0C,EAChDC,KAAKF,IAAMA,EACXE,KAAKD,QAAUA,EAdnB,yCAiBE,SAAcD,GACZ,MAAM,GAAN,OAAUE,KAAKF,IAAf,YAAsBA,KAlB1B,wDAqBE,WAAUG,GAAV,qBAAAjB,EAAA,yDACQc,EAAME,KAAKE,MAAMD,KACjBE,EAAWC,aAAaC,QAAQP,IAFxC,uBAIUQ,EAASC,KAAKC,MAAML,GAJ9B,kBAKWG,GALX,uBAOoBN,KAAKD,QAAQE,GAPjC,YAOQN,EAPR,gCASIS,aAAaK,QAAQX,EAAKS,KAAKG,UAAUf,IAT7C,kBAUWA,GAVX,iDArBF,8DC+BMgB,EAAe,IAAId,EACvB,UADmB,uCAEnB,WAAOpC,GAAP,yBAAAuB,EAAA,sEAGwB4B,IAAQC,eAAeC,QAAQrD,GAHvD,cAGQsD,EAHR,OAIQC,EAAcD,EAAQE,UAAUC,MACpC,SAACC,GAAD,OAAaA,EAAQC,cALzB,SAOwBR,IAAQS,QAAQP,QAAQE,EAAYjD,QAAQN,MAPpE,cAOQM,EAPR,OAWQuD,EAAoBvD,EAAQH,GAC5B2D,EAAaxD,EAAQyD,QAAQC,cAC7BC,EAAQX,EAAQW,MAAMC,QAAO,SAACC,EAAKzC,GAEvC,OADAyC,EAAIzC,EAAI0C,SAASpE,MAAoB0B,EAAI1B,KAClCmE,IACN,IAhBL,kBAkBS,CACLN,oBACAC,aACAG,UArBJ,4CAFmB,uDAwCfI,EAAY,IAAIjC,EAAsB,QAA1B,uCAAmC,WAAOkC,GAAP,uBAAA/C,EAAA,sEAEhC4B,IAAQoB,QAAQlB,QAAQiB,GAFQ,cAE7CpE,EAF6C,gBAG/BiD,IAAQqB,YAAYnB,QAAQnD,EAAKuE,cAAczE,MAHhB,cAG7C0E,EAH6C,OAO7CvE,EAAKD,EAAKF,KACViE,EAAQ/D,EAAK+D,MAAMC,QAAO,SAACC,EAAKzC,GAEpC,OADAyC,EAAIzC,EAAI0C,SAASpE,MAAoB0B,EAAI1B,KAClCmE,IACN,IACG/D,EAAUsE,EAAMC,UAAUC,KAAI,SAACC,GAAD,OAASA,EAAI7E,QAZE,kBAc5C,CACLG,KACA8D,QACA7D,YAjBiD,4CAAnC,uDAgCZ0E,EAAe,IAAI1C,EACvB,UADmB,uCAEnB,WAAOpC,GAAP,uBAAAuB,EAAA,sEAEoB4B,IAAQ4B,QAAQ1B,QAAQrD,GAF5C,cAEQ6E,EAFR,OAMQ1E,EAAK0E,EAAI7E,KACTiE,EAAQY,EAAIZ,MAAMC,QAAO,SAACC,EAAKzC,GAEnC,OADAyC,EAAIzC,EAAI0C,SAASpE,MAAoB0B,EAAI1B,KAClCmE,IACN,KAMGa,EAAiBH,EAAII,gBAAgBL,KAAI,SAACM,GAAD,MAAY,CACzDlF,KAAMkF,EAAMC,gBAAgBnF,KAC5BoF,IAAKF,EAAMG,kBAEEC,MAAK,SAAC/D,EAAGgE,GACtB,OAAIhE,EAAE6D,IAAMG,EAAEH,IACL,EACE7D,EAAE6D,IAAMG,EAAEH,KACX,EAED,KAGL9E,EAAU0E,EAAeJ,KAAI,SAACM,GAAD,OAAWA,EAAMlF,QA7BtD,kBA+BS,CACLG,KACA8D,QACA3D,YAlCJ,2CAFmB,uD,SAiDNkF,E,8EAAf,WAAiCC,GAAjC,qBAAAlE,EAAA,sEAEwB4B,IAAQuC,YAAYC,UAF5C,cAEQC,EAFR,OAKQC,EAAcD,EAAQE,QAAQlB,KAAI,SAACmB,GAAD,OACtC5C,IAAQuC,YAAYrC,QAAQ0C,EAAI/F,SANpC,SAQ4BgC,QAAQgE,IAAIH,GARxC,cAQQI,EARR,OAWQC,EAAyB,GAC/BD,EAAYE,SAAQ,SAACJ,GACnB,IAAMK,EAAUL,EAAI9B,MAAMR,MAAK,SAACzD,GAAD,OAAUA,EAAKoE,SAASpE,OAASyF,KAC5DW,GACFF,EAAKpE,KAAK,CACR9B,KAAMoG,EAAQpG,KACdG,GAAI4F,EAAI5F,QAjBhB,kBAsBS+F,GAtBT,6C,sBAgFA,IAAMG,EAAsBC,IAAI,uCAC9B,WAAOb,EAAgBc,GAAvB,uBAAAhF,EAAA,sEACqBuD,EAAa0B,IAAID,GADtC,cACQ1B,EADR,OAEQ4B,EAAkB5B,EAAIvE,QAAQsE,KAAI,SAAC8B,GAAD,OAAUxD,EAAasD,IAAIE,MAFrE,SAGoCrF,EAChCoF,EACA,IALJ,cAGQE,EAHR,OAOQC,EAAkBD,EAAoBE,QAC1C,SAACC,GAAD,MAAoB,cAAbA,EAAEC,UAA4BD,EAAE3F,SAEnC6F,EAAgBJ,EAAgBhC,KAAI,SAACkC,GAAD,OAAOA,EAAE3F,SAVrD,kBAWS6F,EAAcpC,KAAI,SAAC8B,GAAD,MAAW,CAClC1G,KAAM0G,EAAKzC,MAAMwB,GACjB3B,WAAY4C,EAAK5C,WACjBD,kBAAmB6C,EAAK7C,uBAd5B,4CAD8B,yD,SAoBVoD,E,gFAAf,WACLxB,EACAyB,GAFK,yBAAA3F,EAAA,sDAOL,IAFI4F,EAAaD,EACXE,EAAgE,GAC/DD,EAAa,GAClBC,EAAYtF,KAAKqB,IAAQuC,YAAYrC,QAAQ8D,IAC7CA,IATG,gBAWcnF,QAAQgE,IAAIoB,GAX1B,cAWClB,EAXD,OAaCmB,EAAgD,GACtDnB,EAAKC,SAAQ,SAACJ,GACZA,EAAIZ,gBAAgBgB,SAAQ,SAACO,GAC3B,IAAMY,EAAIpE,EAAasD,IAAIE,EAAK1G,MAChCqH,EAAavF,KAAKwF,SAjBjB,UAqBajG,EAAuBgG,EAAc,KArBlD,eAqBCnF,EArBD,OAsBC5B,EAAqB4B,EACxB2E,QAAO,SAACC,GAAD,MAAoB,cAAbA,EAAEC,UAA4BD,EAAE3F,SAC9CyD,KAAI,SAACkC,GAAD,MAAQ,CAEX9G,KAAM8G,EAAE3F,MAAM8C,MAAMwB,GAEpB5B,kBAAmBiD,EAAE3F,MAAMhB,GAE3BE,WAAYyG,EAAE3F,MAAMd,WAEpByD,WAAYgD,EAAE3F,MAAM2C,eAhCnB,kBAmCExD,GAnCF,6C,sBA+CP,IAAMiH,EAAcjB,IAAI,uCAAC,WAAOb,GAAP,qBAAAlE,EAAA,sEACK4B,IAAQoB,QAAQoB,UADrB,cACjB6B,EADiB,OAEjBC,EAAeD,EAAc1B,QAAQlB,KAAI,SAAC1C,GAAD,OAC7CmC,EAAUmC,IAAItE,EAAIlC,SAHG,SAKGgC,QAAQgE,IAAIyB,GALf,cAKjBC,EALiB,OAMjBC,EAAWD,EAAYb,QAAO,SAAC3G,GAAD,QAAYA,KANzB,kBAQrByH,EAGGd,QAAO,SAAC3G,GAAD,OAAUA,EAAKE,QAAQuB,OAAS,KACvCiD,KAAI,SAACgD,GAAD,MAAY,CACfzH,GAAIyH,EAAMzH,GACVH,KAAM4H,EAAM3D,MAAMwB,GAClBrF,QAASwH,EAAMxH,aAfE,2CAAD,uDA6BlByH,EAAmBvB,IAAI,uCAAC,WAAOb,EAAgBqC,GAAvB,yBAAAvG,EAAA,sEAGR8C,EAAUmC,IAAIsB,GAHN,cAGtB5H,EAHsB,OAItB6H,EAAW7H,EAAKE,QAChB4H,EAAcD,EAASnD,KAAI,SAAC5E,GAAD,OAAU8E,EAAa0B,IAAIxG,MALhC,SAMFgC,QAAQgE,IAAIgC,GANV,cAMtBC,EANsB,OAOtBN,EAAWM,EAAYpB,QAAO,SAAChC,GAAD,QAAWA,KACzCqD,EAAgBP,EAAS/C,KAAI,SAACgD,GAAD,MAAY,CAC7CzH,GAAIyH,EAAMzH,GACVH,KAAM4H,EAAM3D,MAAMwB,GAClBnF,QAASsH,EAAMtH,YAXW,kBAcrB4H,GAdqB,4CAAD,yDAyBhBC,EAAb,WAGE,cAAuC,IAAD,IAAxB1C,YAAwB,MAAjB,KAAiB,2BAF9BrB,cAE8B,EACpC7B,KAAK6B,SAAWqB,EAJpB,sFAOE,sBAAAlE,EAAA,sEACegG,EAAYhF,KAAK6B,UADhC,wFAPF,2HAWE,WAAuBlE,GAAvB,SAAAqB,EAAA,sEACesG,EAAiBtF,KAAK6B,SAAUlE,EAAKC,IADpD,wFAXF,+HAeE,WAA0B0E,GAA1B,SAAAtD,EAAA,sEACe8E,EAAoB9D,KAAK6B,SAAUS,EAAI1E,IADtD,wFAfF,6HAmBE,sBAAAoB,EAAA,sEACeiE,EAAkBjD,KAAK6B,UADtC,wFAnBF,iIAuBE,WAA6B/D,GAA7B,SAAAkB,EAAA,sEACe0F,EAAuB1E,KAAK6B,SAAU/D,EAAWF,IADhE,wFAvBF,8DC1WMiI,EAAgB,IAAID,EAAW,CAAE1C,KAAM,OAEhC4C,EAAoBtH,wBAA0BqH,GAOpD,SAASE,EAAmBC,GACjC,MAA4BC,mBAAS,IAAIL,EAAW,CAAE1C,KAAM8C,EAAM9C,QAAlE,mBAAOgD,EAAP,KAAeC,EAAf,KAMA,OAJAC,qBAAU,WACRD,EAAU,IAAIP,EAAW,CAAE1C,KAAM8C,EAAM9C,UACtC,CAAC8C,EAAM9C,OAGR,cAAC4C,EAAkBjH,SAAnB,CAA4BD,MAAOsH,EAAnC,SACGF,EAAMtH,W,iICCN,SAAS2H,GAAsCL,GAAyB,IAAD,EACtEM,EAAc,IAAIC,IACxBP,EAAMQ,KAAK5C,SAAQ,SAAC6C,GAClBH,EAAYI,IAAIV,EAAMW,SAASF,GAAIA,MAgBrC,OACE,eAACG,EAAA,EAAD,CAAaC,UAAS,UAAEb,EAAMa,iBAAR,SAAtB,UACE,cAACC,EAAA,EAAD,CAAYC,QAASf,EAAMpI,GAA3B,SAAgCoI,EAAMgB,QACtC,cAACC,EAAA,EAAD,CACErJ,GAAIoI,EAAMpI,GACVgB,MAAOoH,EAAMW,SAASX,EAAMpH,OAC5BsI,SAZe,SAACC,GACpB,IAAMvI,EAAQuI,EAAMC,OAAOxI,MACrByI,EAAYf,EAAYrC,IAAIrF,GAClCoH,EAAMkB,SAASG,IAMb,SAKGrB,EAAMQ,KAAKnE,KAAI,SAACoE,GAAD,OACd,cAACa,GAAA,EAAD,CAAqC1I,MAAOoH,EAAMW,SAASF,GAA3D,SACGT,EAAMuB,gBAAgBd,IADVT,EAAMwB,YAAYf,Y,2CChCrCgB,GAAgBC,YAAW,CAC/BC,KAAM,CACJC,QAAS,QAETC,WAAY,SAAC7B,GACX,OAAQA,EAAM8B,SACZ,IAAK,aACH,OAAOC,KAAK,KAEd,IAAK,WACH,OAAOC,KAAI,KAEb,IAAK,OACH,OAAOC,KAAS,IAElB,QACE,MAAO,iBAKfC,MAAO,CACLN,QAAS,WAUN,SAASO,GAAT,GAA0D,IAA1CL,EAAyC,EAAzCA,QAASM,EAAgC,EAAhCA,QAAS1J,EAAuB,EAAvBA,SACjC2J,EAASZ,GAAc,CAAEK,YAC/B,OACE,oBAAIQ,UAAWD,EAAOV,KAAMS,QAASA,EAArC,SACG1J,IASP,IAAM6J,GAAiBb,YAAW,CAChCC,KAAM,CACJC,QAAS,OACTY,oBAAqB,SAACxC,GAAD,uBACTA,EAAMtI,QADG,mBAGrB+K,UAAW,OACXC,QAAS,KAUN,SAASC,GAAT,GAImB,IAHxBjL,EAGuB,EAHvBA,QACAkL,EAEuB,EAFvBA,MACAC,EACuB,EADvBA,WAEMR,EAASE,GAAe,CAAE7K,YAChC,OACE,oBAAI4K,UAAWD,EAAOV,KAAtB,SAA6BiB,EAAMvG,KAAI,SAACyG,GAAD,OAAUD,EAAWC,QAShE,IAAMC,GAA0BrB,YAAW,CACzCC,KAAM,SAAC3B,GAAD,cAAsC,CAC1CgD,MAAK,UAAEhD,EAAMgD,aAAR,QAAiB,OACtBC,OAAM,UAAEjD,EAAMiD,cAAR,QAAkB,QACxBC,SAAU,aAQP,SAASC,GAAT,GAA4D,IAAlCzK,EAAiC,EAAjCA,SACzB2J,EAASU,GAAwB,IACvC,OAAO,cAACK,GAAA,EAAD,CAAKd,UAAWD,EAAOV,KAAvB,SAA8BjJ,IC/EvC,IAAM2K,GAAkB3B,YAAW,CACjCC,KAAM,CACJe,QAAS,OACTY,OAAQ,OACR,wBAAyB,CACvBC,UAAW,WASjB,SAASC,KACP,IAAMnB,EAASgB,KACP/K,EAAamL,qBAAWlL,GAAxBD,SACR,EAA0B2H,mBAAoB,CAAExI,KAAM,KAAtD,mBAAOQ,EAAP,KAAcyL,EAAd,KAkBA,OACE,cAACC,EAAA,EAAD,CAAWC,OAAK,EAACC,SAAS,KAA1B,SACE,cAACC,EAAA,EAAD,CAAOxB,UAAWD,EAAOV,KAAzB,SACE,uBAAMoC,SAZS,SAAC5C,GACpBA,EAAM6C,iBACN1L,EAAS,CAAEH,KAAM,YAAaC,QAAS,CAAEX,KAAMQ,EAAMR,QACrDa,EAAS,CACPH,KAAM,eACNC,QAAS,CAAEX,KAAK,GAAD,OAAKQ,EAAMR,KAAX,gBAOb,UACE,cAACwM,EAAA,EAAD,CACEjD,MAAM,eACNE,SAtBe,SAACC,GACxBuC,EAAS,2BACJzL,GADG,IAENR,KAAM0J,EAAMC,OAAOxI,UAoBbA,MAAOX,EAAMR,KACboJ,WAAS,IAEX,cAACqD,EAAA,EAAD,CAAQ/L,KAAK,SAAS0I,WAAS,EAA/B,gCAaV,IAAM0B,GAAiBb,YAAW,CAChCC,KAAM,CACJe,QAAS,OACTmB,SAAU,QACVP,OAAQ,OACR,0BAA2B,CACzBC,UAAW,WAKjB,SAASY,KAGP,MAA0BlE,mBAAiB,IAA3C,mBAAOmE,EAAP,KAAcC,EAAd,KACA,EAA0BpE,mBAAoB,IAA9C,mBAAOqE,EAAP,KAAcC,EAAd,KAEA,EAA4Bd,qBAAWlL,GAA/BN,EAAR,EAAQA,MAAOK,EAAf,EAAeA,SACT4H,EAASuD,qBAAW3D,GAEpBuC,EAASE,KA0Df,OAlCAnC,qBAAU,YACG,uCAAG,4BAAApH,EAAA,sEACQkH,EAAOlB,cADf,OACNoF,EADM,OAEZC,EAASD,GAFG,2CAAH,qDAIXI,KACC,CAACtE,IAUJE,qBAAU,YACG,uCAAG,4BAAApH,EAAA,sEACQkH,EAAOZ,iBAAiBrH,EAAMT,MAAMG,MAD5C,OACN2M,EADM,OAEZC,EAASD,GAFG,2CAAH,qDAIXE,KACC,CAACtE,EAAQ5H,EAAUL,EAAMT,MAAMG,OAElCyI,qBAAU,YACG,uCAAG,4BAAApH,EAAA,sEACUkH,EAAOpC,oBAAoB7F,EAAMT,MAAMK,SADjD,OACNE,EADM,OAEZO,EAAS,CAAEH,KAAM,kBAAmBC,QAASL,IAFjC,2CAAH,qDAIXyM,KACC,CAACtE,EAAQ5H,EAAUL,EAAMT,MAAMK,UAKhC,eAAC4M,EAAA,EAAD,CAAMC,WAAS,EAAf,UACE,cAACD,EAAA,EAAD,CAAMC,WAAS,EAAC5B,MAAI,EAAC6B,GAAI,EAAzB,SACE,eAACb,EAAA,EAAD,CAAOc,UAAU,OAAOtC,UAAWD,EAAOV,KAA1C,UACE,cAACsC,EAAA,EAAD,CACEpD,WAAS,EACTG,MAAM,aACNE,SA7De,SAACC,GACxB,IAAM1J,EAAO0J,EAAMC,OAAOxI,MAC1BN,EAAS,CAAEH,KAAM,eAAgBC,QAAS,CAAEX,WA4DpCmB,MAAOX,EAAMT,MAAMC,OAErB,eAACmJ,EAAA,EAAD,CAAaC,WAAS,EAAtB,UACE,cAACC,EAAA,EAAD,CAAYC,QAAQ,eAApB,qBACA,cAAC8D,EAAA,EAAD,CACEjN,GAAG,eACHO,KAAK,SACL+I,SAhEe,SAACC,GAC1B,IAAMzJ,EAAUoN,OAAO3D,EAAMC,OAAOxI,OACpCN,EAAS,CAAEH,KAAM,kBAAmBC,QAAS,CAAEV,cA+DrCkB,MAAOX,EAAMT,MAAME,aAGvB,cAAC2I,GAAD,CACEzI,GAAG,cACHoJ,MAAM,OACNH,WAAS,EACTL,KAAM4D,EACNxL,MAAOX,EAAMT,MAAMG,KACnB4J,gBAAiB,SAACd,GAAD,OAAOA,EAAEhJ,MAC1B+J,YAAa,SAACf,GAAD,OAAOA,EAAEhJ,MACtBkJ,SAAU,SAACF,GAAD,OAAOA,EAAE7I,IACnBsJ,SAxEe,SAACvJ,GACxBW,EAAS,CAAEH,KAAM,eAAgBC,QAAST,OAyEpC,cAAC0I,GAAD,CACEzI,GAAG,iBACHoJ,MAAM,UACNH,WAAS,EACTL,KAAM8D,EACN1L,MAAOX,EAAMT,MAAMK,QACnB0J,gBAAiB,SAACd,GAAD,OAAOA,EAAEhJ,MAC1B+J,YAAa,SAACf,GAAD,OAAOA,EAAEhJ,MACtBkJ,SAAU,SAACF,GAAD,OAAOA,EAAE7I,IACnBsJ,SA/EkB,SAAC5E,GAC3BhE,EAAS,CAAEH,KAAM,kBAAmBC,QAASkE,YAkF3C,cAACmI,EAAA,EAAD,CAAMC,WAAS,EAAC5B,MAAI,EAAC6B,GAAI,GAAzB,SACE,cAACxB,GAAD,UACE,cAACR,GAAD,CACEjL,QAASO,EAAMT,MAAME,QACrBkL,MAAO3K,EAAMT,MAAMO,QACnB8K,WAAY,SAACC,GAAD,OACV,cAACX,GAAD,CAAsBL,QAAQ,UAA9B,SACE,qBAAKiD,IAAKjC,EAAKvH,WAAYyJ,IAAKlC,EAAKrL,QAD5BqL,EAAKrL,gBAWvB,SAASwN,KAEd,OADkBxB,qBAAWlL,GAArBN,MACEZ,MAAMC,OACP,cAAC6M,GAAD,IAEF,cAACX,GAAD,ICtLM0B,OA9Bf,WACE,OAOE,aANA,CAMCzM,EAAD,UACE,cAACsH,EAAD,CAAoB7C,KAAK,KAAzB,SASE,cAAC,IAAD,CAAQiI,SAAS,WAAjB,SACE,cAAC,IAAD,UACE,cAAC,IAAD,CAAOC,OAAK,EAACC,KAAK,IAAlB,SACE,cAACJ,GAAD,eChCCK,GAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,O,oBCFdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,eAACC,GAAA,EAAD,WACE,cAACC,GAAA,EAAD,IACA,cAAC,GAAD,SAGJC,SAASC,eAAe,SAM1Bf,M","file":"static/js/main.628b4e50.chunk.js","sourcesContent":["/**\n * @TODO - Here it is, all the fucking state! I can't think\n * of a better way to structure this right now, so I\n * won't. In time, it will probably be better to start\n * breaking this out into separate state managers, for\n * organization as much as performance\n *\n * ~reccanti 6/19/2021\n */\nimport { createContext, ReactNode, useReducer } from \"react\";\nimport { Pokemon, PokeGeneration, Game, Pokedex } from \"./utils/pokeGetter\";\n\n// various types for interacting with state\n\ninterface User {\n  name: string;\n}\n\ninterface BoardConfig {\n  name: string;\n  columns: number;\n  generation: PokeGeneration;\n  game: Game;\n  pokemon: Pokemon[];\n  pokedex: Pokedex;\n}\n\n// compose all our types into a state blob. Create the reducer\n// and action for managing this\n\ninterface FuckingState {\n  users: {\n    player: User | null;\n    opponent: User | null;\n  };\n  board: BoardConfig;\n}\n\nconst initialState: FuckingState = {\n  users: {\n    player: null,\n    opponent: null,\n  },\n  board: {\n    name: \"\",\n    columns: 15,\n    game: {\n      id: \"red\",\n      name: \"Red\",\n      pokedex: [],\n    },\n    generation: {\n      id: 1,\n      name: \"Generation I\",\n    },\n    pokedex: {\n      id: \"kanto\",\n      name: \"Kanto\",\n      pokemon: [],\n    },\n    pokemon: [],\n  },\n};\n\ninterface BaseAction {\n  type: string;\n}\n\ninterface SetPlayer extends BaseAction {\n  type: \"setPlayer\";\n  payload: {\n    name: string;\n  };\n}\n\ninterface SetBoardName extends BaseAction {\n  type: \"setBoardName\";\n  payload: {\n    name: string;\n  };\n}\n\ninterface SetBoardColumns extends BaseAction {\n  type: \"setBoardColumns\";\n  payload: {\n    columns: number;\n  };\n}\n\ninterface SetBoardGeneration extends BaseAction {\n  type: \"setBoardGeneration\";\n  payload: PokeGeneration;\n}\n\ninterface SetBoardPokemon extends BaseAction {\n  type: \"setBoardPokemon\";\n  payload: Pokemon[];\n}\n\ninterface SetBoardGame extends BaseAction {\n  type: \"setBoardGame\";\n  payload: Game;\n}\n\ninterface SetBoardPokedex extends BaseAction {\n  type: \"setBoardPokedex\";\n  payload: Pokedex;\n}\n\ntype Action =\n  | SetPlayer\n  | SetBoardName\n  | SetBoardColumns\n  | SetBoardGeneration\n  | SetBoardPokemon\n  | SetBoardGame\n  | SetBoardPokedex;\n\nfunction reducer(state: FuckingState, action: Action): FuckingState {\n  switch (action.type) {\n    case \"setPlayer\": {\n      return {\n        ...state,\n        users: {\n          ...state.users,\n          player: {\n            name: action.payload.name,\n          },\n        },\n      };\n    }\n    case \"setBoardColumns\": {\n      return {\n        ...state,\n        board: {\n          ...state.board,\n          columns: action.payload.columns,\n        },\n      };\n    }\n    case \"setBoardName\": {\n      return {\n        ...state,\n        board: {\n          ...state.board,\n          name: action.payload.name,\n        },\n      };\n    }\n    case \"setBoardGeneration\": {\n      return {\n        ...state,\n        board: {\n          ...state.board,\n          generation: {\n            ...action.payload,\n          },\n        },\n      };\n    }\n    case \"setBoardGame\": {\n      return {\n        ...state,\n        board: {\n          ...state.board,\n          game: {\n            ...action.payload,\n          },\n        },\n      };\n    }\n    case \"setBoardPokemon\": {\n      return {\n        ...state,\n        board: {\n          ...state.board,\n          pokemon: [...action.payload],\n        },\n      };\n    }\n    case \"setBoardPokedex\": {\n      return {\n        ...state,\n        board: {\n          ...state.board,\n          pokedex: {\n            ...action.payload,\n          },\n        },\n      };\n    }\n    default: {\n      return state;\n    }\n  }\n}\n\n// combine the state blob with a dispatch function and actions\n// to create the context and Provider\n\ninterface FuckingContext {\n  state: FuckingState;\n  dispatch: (action: Action) => void;\n}\n\nconst initialContext: FuckingContext = {\n  state: initialState,\n  dispatch() {},\n};\n\nexport const AllTheFuckingStateCtx =\n  createContext<FuckingContext>(initialContext);\n\ninterface Props {\n  children: ReactNode;\n}\n\nexport function AllTheFuckingStateProvider({ children }: Props) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const value: FuckingContext = {\n    state,\n    dispatch,\n  };\n  return (\n    <AllTheFuckingStateCtx.Provider value={value}>\n      {children}\n    </AllTheFuckingStateCtx.Provider>\n  );\n}\n","/**\n * A drop-in replacement for Promise.all, except you can specify a chunk size.\n * This way, you can chunk your requests so that you don't overwhelm the API.\n *\n * @METEORCITY_CANDIDATE\n * - maybe make \"options\" instead of passing the chunksize as a full parameter\n */\nexport async function PromiseAllSettledChunk<T>(\n  ps: Promise<T>[],\n  chunkSize: number = 25\n): Promise<PromiseSettledResult<T>[]> {\n  // split the array into chunks\n  const pchunks: Promise<T>[][] = [];\n  let cur = 0;\n  while (cur < ps.length) {\n    const chunk = ps.slice(cur, cur + chunkSize);\n    pchunks.push(chunk);\n    cur += chunkSize;\n  }\n\n  // asynchronously iterate through each chunk and add the results\n  let allRes: PromiseSettledResult<T>[] = [];\n  for (const chunk of pchunks) {\n    const res = await Promise.allSettled(chunk);\n    allRes = allRes.concat(res);\n  }\n\n  return allRes;\n}\n","/**\n * A cool cache for cool people 😎. This cache\n * wraps around API calls and caches the results\n * in localStorage\n *\n * @METEORCITY_CANDIDATE\n * - I don't really like the Promise<T | void> signature.\n *   Maybe come up with some sort of CacheResponse type?\n * - better error handling\n */\n\n/**\n * A function that will be used to fetch a value if it isn't\n * stored in the cache already\n */\ntype LookerUpper<T> = (lookupVal: string) => T | Promise<T | void>;\n\nexport class CoolCache<T> {\n  /**\n   * This key will be used to identify the resource in localStorage\n   */\n  private key: string;\n\n  /**\n   * This will be used to look up the value if it isn't available\n   * in localStorage\n   */\n  private handler: LookerUpper<T>;\n\n  constructor(key: string, handler: LookerUpper<T>) {\n    this.key = key;\n    this.handler = handler;\n  }\n\n  private mkKey(key: string): string {\n    return `${this.key}.${key}`;\n  }\n\n  async get(lookupVal: string): Promise<T | void> {\n    const key = this.mkKey(lookupVal);\n    const localVal = localStorage.getItem(key);\n    if (localVal) {\n      const parsed = JSON.parse(localVal) as T;\n      return parsed;\n    }\n    const res = await this.handler(lookupVal);\n    if (res) {\n      localStorage.setItem(key, JSON.stringify(res));\n      return res;\n    }\n  }\n}\n","/**\n * This is kind of an extension of what I started with pokeFuncs.\n * The goal here is to create an wrapper around the PokeAPI that can\n * be used to simplify the process of fetching pokemon and formatting\n * it in the way I'd like.\n *\n * @TODO - Even though pokeapi-typescript caches our API requests,\n * we might want to pull all this down and host all the data locally.\n * By having this Getter, we can preserve the API our app uses while\n * swapping out the data source\n */\nimport PokeAPI, { IPokemonSpeciesVariety } from \"pokeapi-typescript\";\nimport memo from \"micro-memoize\";\nimport { PromiseAllSettledChunk } from \"./PromiseAllChunk\";\nimport { CoolCache } from \"./CoolCache\";\n\n/**\n * All the languages that information could be\n * displayed in\n */\nexport type Language =\n  | \"ja-Hrkt\"\n  | \"roomaji\"\n  | \"ko\"\n  | \"zh-Hant\"\n  | \"fr\"\n  | \"de\"\n  | \"es\"\n  | \"it\"\n  | \"en\"\n  | \"cs\"\n  | \"ja\"\n  | \"zh-Hans\"\n  | \"pt-BR\";\n\n/**\n * The Pokemon Cache contains all the information needed to display\n * and work with Pokemon data. When needed, objects are used instead\n * of arrays in order to decrease the time needed\n */\ninterface IPokemonCache {\n  nationalDexNumber: number;\n  artworkUrl: string;\n  names: {\n    [lang in Language]: string;\n  };\n}\n\nconst PokemonCache = new CoolCache<IPokemonCache>(\n  \"pokemon\",\n  async (name: string) => {\n    // first, look up the Pokemon species and fetch the\n    // resource for its default variety\n    const species = await PokeAPI.PokemonSpecies.resolve(name);\n    const defaultForm = species.varieties.find(\n      (variety) => variety.is_default\n    ) as IPokemonSpeciesVariety;\n    const pokemon = await PokeAPI.Pokemon.resolve(defaultForm.pokemon.name);\n\n    // extract the ID, name, and artwork for the pokemon. Put it in a format\n    // that's faster to search than an array\n    const nationalDexNumber = pokemon.id;\n    const artworkUrl = pokemon.sprites.front_default;\n    const names = species.names.reduce((acc, cur) => {\n      acc[cur.language.name as Language] = cur.name;\n      return acc;\n    }, {} as { [lang in Language]: string });\n\n    return {\n      nationalDexNumber,\n      artworkUrl,\n      names,\n    };\n  }\n);\n\n/**\n * The Game Cache contains all the information needed to get game-related\n * information\n */\ninterface IGameCache {\n  id: string;\n  names: {\n    [lang in Language]: string;\n  };\n  pokedex: string[];\n}\n\nconst GameCache = new CoolCache<IGameCache>(\"games\", async (title: string) => {\n  // get the game and the version group that game belongs to\n  const game = await PokeAPI.Version.resolve(title);\n  const group = await PokeAPI.VerionGroup.resolve(game.version_group.name);\n\n  // extract the ID, names, and pokedex and put it in a format\n  // that's faster to search than an array\n  const id = game.name;\n  const names = game.names.reduce((acc, cur) => {\n    acc[cur.language.name as Language] = cur.name;\n    return acc;\n  }, {} as { [lang in Language]: string });\n  const pokedex = group.pokedexes.map((dex) => dex.name);\n\n  return {\n    id,\n    names,\n    pokedex,\n  };\n});\n\n/**\n * The Pokedex cache is where we keep all pokedex info\n */\ninterface IPokedexCache {\n  id: string;\n  names: {\n    [lang in Language]: string;\n  };\n  pokemon: string[];\n}\n\nconst PokedexCache = new CoolCache<IPokedexCache>(\n  \"pokedex\",\n  async (name: string) => {\n    // get the pokedex\n    const dex = await PokeAPI.Pokedex.resolve(name);\n\n    // extract the ID, names, and pokemon and put it in a\n    // format  that's faster to search than an array\n    const id = dex.name;\n    const names = dex.names.reduce((acc, cur) => {\n      acc[cur.language.name as Language] = cur.name;\n      return acc;\n    }, {} as { [lang in Language]: string });\n    /**\n     * @NOTE this is a little complicated. What we're doing here\n     * is creating list of pokemon sorted by the pokedex order,\n     * which involves several steps\n     */\n    const pokemonEntries = dex.pokemon_entries.map((entry) => ({\n      name: entry.pokemon_species.name,\n      num: entry.entry_number,\n    }));\n    pokemonEntries.sort((a, b) => {\n      if (a.num > b.num) {\n        return 1;\n      } else if (a.num < b.num) {\n        return -1;\n      } else {\n        return 0;\n      }\n    });\n    const pokemon = pokemonEntries.map((entry) => entry.name);\n\n    return {\n      id,\n      names,\n      pokemon,\n    };\n  }\n);\n\nexport interface PokeGeneration {\n  name: string;\n  id: number;\n}\n\n/**\n * Fetch all the Pokemon generations\n */\nasync function getAllGenerations(lang: Language): Promise<PokeGeneration[]> {\n  // list out all the generations\n  const genList = await PokeAPI.Generaition.listAll();\n\n  // get info from all of the generations\n  const genRequests = genList.results.map((gen) =>\n    PokeAPI.Generaition.resolve(gen.name)\n  );\n  const genInfoDump = await Promise.all(genRequests);\n\n  // parse out that info into a list of our generations\n  const gens: PokeGeneration[] = [];\n  genInfoDump.forEach((gen) => {\n    const genName = gen.names.find((name) => name.language.name === lang);\n    if (genName) {\n      gens.push({\n        name: genName.name,\n        id: gen.id,\n      });\n    }\n  });\n\n  return gens;\n}\n\n/**\n * Get info on all the pokemon available in each generation\n *\n * @TODO - This logic is incomplete and probably bad. I think this\n * is the flow I'd like to encourage:\n *\n * 1. Select the game you're playing\n * 2. Use that to find the version group\n * 3. Use that to find the generation\n * 4. Find all the pokemon-species in that generation\n * 5. Get the names of all the varieties of that species\n * 6. Look up all those varieties\n *\n * This is kind of unmanegeable in it's current form. I think\n * what I'd like to do is create a \"Cache\" layer that will look\n * something like this:\n *\n * {\n *   pokemon: {...},\n *   games: {...}\n * }\n *\n * The cache will work like this:\n *\n * ```\n * Cache.get(\"pokemon\").get(\"crobat\")\n * ```\n *\n * or\n *\n * ```\n * Cache.get(\"games\").get(\"pokemon\")\n * ```\n *\n * It will work like this:\n *\n * 1. Does that request exist as a memoized value in the cache?\n *    If so, return that\n * 2. Does the entry exist in the cache? If so, lookup the value\n *    and return that\n * 3. Otherwise, make a request to the PokeAPI, store the value\n *    in localstorage, and then return the result\n *\n * Maybe multiple Caches for each type would be easier to implement\n * and manage?\n *\n * ~reccanti 6/22/21\n */\n\nexport interface Pokemon {\n  nationalDexNumber: number;\n  name: string;\n  artworkUrl: string;\n}\n\nconst getPokemonByPokedex = memo(\n  async (lang: Language, dexName: string): Promise<Pokemon[]> => {\n    const dex = (await PokedexCache.get(dexName)) as IPokedexCache;\n    const pokemonPromises = dex.pokemon.map((poke) => PokemonCache.get(poke));\n    const pokemonCacheResults = await PromiseAllSettledChunk(\n      pokemonPromises,\n      50\n    );\n    const pokemonAccepted = pokemonCacheResults.filter(\n      (r) => r.status === \"fulfilled\" && !!r.value\n    ) as PromiseFulfilledResult<IPokemonCache>[];\n    const pokemonCached = pokemonAccepted.map((r) => r.value);\n    return pokemonCached.map((poke) => ({\n      name: poke.names[lang],\n      artworkUrl: poke.artworkUrl,\n      nationalDexNumber: poke.nationalDexNumber,\n    }));\n  }\n);\n\nexport async function getPokemonByGeneration(\n  lang: Language,\n  generationId: number\n): Promise<Pokemon[]> {\n  // based on the generation, cycle backward to get all the pokemon\n  let currentGen = generationId;\n  const genPromises: ReturnType<typeof PokeAPI.Generaition.resolve>[] = [];\n  while (currentGen > 0) {\n    genPromises.push(PokeAPI.Generaition.resolve(currentGen));\n    currentGen--;\n  }\n  const gens = await Promise.all(genPromises);\n\n  const pokePromises: Promise<IPokemonCache | void>[] = [];\n  gens.forEach((gen) => {\n    gen.pokemon_species.forEach((poke) => {\n      const p = PokemonCache.get(poke.name);\n      pokePromises.push(p);\n    });\n  });\n\n  const res = await PromiseAllSettledChunk(pokePromises, 100);\n  const pokemon: Pokemon[] = res\n    .filter((r) => r.status === \"fulfilled\" && !!r.value)\n    .map((r) => ({\n      // @ts-ignore\n      name: r.value.names[lang],\n      // @ts-ignore\n      nationalDexNumber: r.value.id,\n      // @ts-ignore\n      generation: r.value.generation,\n      // @ts-ignore\n      artworkUrl: r.value.artworkUrl,\n    }));\n\n  return pokemon;\n}\n\n/**\n * This is used to get a list of all the mainline Pokemon games\n */\nexport interface Game {\n  id: string;\n  name: string;\n  pokedex: string[];\n}\n\nconst getAllGames = memo(async (lang: Language): Promise<Game[]> => {\n  const gameResources = await PokeAPI.Version.listAll();\n  const gamePromises = gameResources.results.map((res) =>\n    GameCache.get(res.name)\n  );\n  const cachedGames = await Promise.all(gamePromises);\n  const filtered = cachedGames.filter((game) => !!game) as IGameCache[];\n  return (\n    filtered\n      // just filter out games without pokedexes because this won't work otherwise.\n      // seems to be a problem for XD and Colosseum\n      .filter((game) => game.pokedex.length > 0)\n      .map((cache) => ({\n        id: cache.id,\n        name: cache.names[lang],\n        pokedex: cache.pokedex,\n      }))\n  );\n});\n\n/**\n * This is used to get a list of Pokedexes for each game.\n */\nexport interface Pokedex {\n  id: string;\n  name: string;\n  pokemon: string[];\n}\n\nconst getPokedexByGame = memo(async (lang: Language, gameName: string): Promise<\n  Pokedex[]\n> => {\n  const game = (await GameCache.get(gameName)) as IGameCache;\n  const dexNames = game.pokedex;\n  const dexPromises = dexNames.map((name) => PokedexCache.get(name));\n  const cachedDexes = await Promise.all(dexPromises);\n  const filtered = cachedDexes.filter((dex) => !!dex) as IPokedexCache[];\n  const basePokedexes = filtered.map((cache) => ({\n    id: cache.id,\n    name: cache.names[lang],\n    pokemon: cache.pokemon,\n  }));\n\n  return basePokedexes;\n});\n\n/**\n * A wrapper around all of these functions which automatically sets\n * the correct language. Maybe other things in the future\n */\ninterface Options {\n  lang: Language;\n}\n\nexport class PokeGetter {\n  private language: Language;\n\n  constructor({ lang = \"en\" }: Options) {\n    this.language = lang;\n  }\n\n  async getAllGames(): Promise<Game[]> {\n    return await getAllGames(this.language);\n  }\n\n  async getPokedexByGame(game: Game): Promise<Pokedex[]> {\n    return await getPokedexByGame(this.language, game.id);\n  }\n\n  async getPokemonByPokedex(dex: Pokedex): Promise<Pokemon[]> {\n    return await getPokemonByPokedex(this.language, dex.id);\n  }\n\n  async getAllGenerations(): Promise<PokeGeneration[]> {\n    return await getAllGenerations(this.language);\n  }\n\n  async getPokemonByGeneration(generation: PokeGeneration) {\n    return await getPokemonByGeneration(this.language, generation.id);\n  }\n}\n","/**\n * A context that provides a wrapper aound the PokeGetter\n * so that we don't have to reinitialize it everywhere\n */\n\nimport { createContext, useState, useEffect, ReactNode } from \"react\";\nimport { PokeGetter, Language } from \"./utils/pokeGetter\";\n\nconst initialGetter = new PokeGetter({ lang: \"en\" });\n\nexport const PokeGetterContext = createContext<PokeGetter>(initialGetter);\n\ninterface Props {\n  children: ReactNode;\n  lang: Language;\n}\n\nexport function PokeGetterProvider(props: Props) {\n  const [getter, setGetter] = useState(new PokeGetter({ lang: props.lang }));\n\n  useEffect(() => {\n    setGetter(new PokeGetter({ lang: props.lang }));\n  }, [props.lang]);\n\n  return (\n    <PokeGetterContext.Provider value={getter}>\n      {props.children}\n    </PokeGetterContext.Provider>\n  );\n}\n","/**\n * I just want to use objects for Select values. Is that so\n * much to ask for???\n *\n * @METEORCITY_CANDIDATE\n * - Need to make this entirely hook-based, so it isn't dependent on\n *   any particular UI theme\n * - Probably need to figure out that change event type\n */\n\nimport { Select, FormControl, InputLabel, MenuItem } from \"@material-ui/core\";\n\ninterface Props<DataType> {\n  // these are all things that will be passed to the UI elements\n  id: string;\n  label: string;\n  fullWidth?: boolean;\n\n  // these are all things for interacting with complex data\n  data: DataType[];\n  getDisplayValue: (data: DataType) => string;\n  getKeyValue: (data: DataType) => string | number;\n  getValue: (data: DataType) => string | number;\n  onChange: (data: DataType) => void;\n  value: DataType;\n}\n\nexport function BetterSelect<DataType extends object>(props: Props<DataType>) {\n  const stuffLookup = new Map<string | number, DataType>();\n  props.data.forEach((d) => {\n    stuffLookup.set(props.getValue(d), d);\n  });\n\n  /**\n   * @NOTE - this is bleh but the type for the Select component's\n   * onChange function is stupid and I don't want to replicate it.\n   * There'll be a value, so who cares\n   *\n   * ~reccanti 6/20/2021\n   */\n  const handleChange = (event: any) => {\n    const value = event.target.value;\n    const trueValue = stuffLookup.get(value) as DataType;\n    props.onChange(trueValue);\n  };\n\n  return (\n    <FormControl fullWidth={props.fullWidth ?? false}>\n      <InputLabel htmlFor={props.id}>{props.label}</InputLabel>\n      <Select\n        id={props.id}\n        value={props.getValue(props.value)}\n        onChange={handleChange}\n      >\n        {props.data.map((d) => (\n          <MenuItem key={props.getKeyValue(d)} value={props.getValue(d)}>\n            {props.getDisplayValue(d)}\n          </MenuItem>\n        ))}\n      </Select>\n    </FormControl>\n  );\n}\n","/**\n * This contains the presentation components for the Board and the\n * tiles on the board.\n *\n * Tiles can exist in the following states:\n * - not yet guessed\n * - missed\n * - an \"unhit\" ship\n * - a \"hit\" ship\n *\n * There should be no game-logic in these components. How you manage that\n * is up to you.\n */\nimport { ReactNode, SyntheticEvent } from \"react\";\nimport { makeStyles, Box } from \"@material-ui/core\";\nimport { blueGrey, red, teal } from \"@material-ui/core/colors\";\n\nexport type CellVariant = \"ship-hit\" | \"ship-unhit\" | \"miss\" | \"unknown\";\n\ninterface CellStyleProps {\n  variant: CellVariant;\n}\n\nconst useCellStyles = makeStyles({\n  root: {\n    display: \"block\",\n    // padding: \"0.5rem\",\n    background: (props: CellStyleProps) => {\n      switch (props.variant) {\n        case \"ship-unhit\": {\n          return teal[\"500\"];\n        }\n        case \"ship-hit\": {\n          return red[\"500\"];\n        }\n        case \"miss\": {\n          return blueGrey[\"50\"];\n        }\n        default: {\n          return \"transparent\";\n        }\n      }\n    },\n  },\n  image: {\n    display: \"block\",\n  },\n});\n\ninterface CellProps {\n  variant: CellVariant;\n  onClick?: (e: SyntheticEvent<HTMLLIElement>) => void;\n  children: ReactNode;\n}\n\nexport function Cell({ variant, onClick, children }: CellProps) {\n  const styles = useCellStyles({ variant });\n  return (\n    <li className={styles.root} onClick={onClick}>\n      {children}\n    </li>\n  );\n}\n\ninterface BoardStyleProps {\n  columns: number;\n}\n\nconst useBoardStyles = makeStyles({\n  root: {\n    display: \"grid\",\n    gridTemplateColumns: (props: BoardStyleProps) =>\n      `repeat(${props.columns}, max-content)`,\n    // gridGap: \"0.5rem\",\n    listStyle: \"none\",\n    padding: 0,\n  },\n});\n\ninterface BoardProps<DataType> {\n  columns: number;\n  items: DataType[];\n  renderCell: (data: DataType) => ReactNode;\n}\n\nexport function Board<DataType extends object>({\n  columns,\n  items,\n  renderCell,\n}: BoardProps<DataType>) {\n  const styles = useBoardStyles({ columns });\n  return (\n    <ol className={styles.root}>{items.map((item) => renderCell(item))}</ol>\n  );\n}\n\ninterface BoardContainerStyleProps {\n  height?: number | string;\n  width?: number | string;\n}\n\nconst useBoardContainerStyles = makeStyles({\n  root: (props: BoardContainerStyleProps) => ({\n    width: props.width ?? \"100%\",\n    height: props.height ?? \"100vh\",\n    overflow: \"scroll\",\n  }),\n});\n\ninterface BoardContainerProps {\n  children: ReactNode;\n}\n\nexport function BoardContainer({ children }: BoardContainerProps) {\n  const styles = useBoardContainerStyles({});\n  return <Box className={styles.root}>{children}</Box>;\n}\n","/**\n * This is the landing page for the application. This is where the\n * user sets their username and launches their instance. I'm modeling\n * it basically on the landing screen for https://skribbl.io/ since\n * I think it does a really good job!\n */\n\nimport {\n  Paper,\n  Container,\n  TextField,\n  Button,\n  makeStyles,\n  FormControl,\n  Input,\n  InputLabel,\n  Grid,\n} from \"@material-ui/core\";\nimport { useContext, useState, ChangeEvent, FormEvent, useEffect } from \"react\";\nimport { AllTheFuckingStateCtx } from \"./AllTheFuckingState\";\nimport { PokeGetterContext } from \"./PokeGetterContext\";\nimport { Game, Pokedex } from \"./utils/pokeGetter\";\nimport { BetterSelect } from \"./utils/BetterSelect\";\nimport { BoardContainer, Board, Cell } from \"./Board\";\n\n/**\n * This is a sub-page of the landing page. Here, we ask the user to\n * select a username before either creating their board or joining\n * someone at a particular instance.\n *\n * @TODO - right now, we only allow the user to create a new board.\n * Users will be able to join directly using a URL provided by the\n * other player once their board is created.\n *\n * ~reccanti 6/20/2021\n */\nconst useCreateStyles = makeStyles({\n  root: {\n    padding: \"1rem\",\n    margin: \"1rem\",\n    \"& *:not(:first-child)\": {\n      marginTop: \"1rem\",\n    },\n  },\n});\n\ninterface FormState {\n  name: string;\n}\n\nfunction CreateUser() {\n  const styles = useCreateStyles();\n  const { dispatch } = useContext(AllTheFuckingStateCtx);\n  const [state, setState] = useState<FormState>({ name: \"\" });\n\n  const handleNameChange = (event: ChangeEvent<HTMLInputElement>) => {\n    setState({\n      ...state,\n      name: event.target.value,\n    });\n  };\n\n  const handleSubmit = (event: FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    dispatch({ type: \"setPlayer\", payload: { name: state.name } });\n    dispatch({\n      type: \"setBoardName\",\n      payload: { name: `${state.name}'s board` },\n    });\n  };\n\n  return (\n    <Container fixed maxWidth=\"sm\">\n      <Paper className={styles.root}>\n        <form onSubmit={handleSubmit}>\n          <TextField\n            label=\"Display Name\"\n            onChange={handleNameChange}\n            value={state.name}\n            fullWidth\n          />\n          <Button type=\"submit\" fullWidth>\n            Get Started\n          </Button>\n        </form>\n      </Paper>\n    </Container>\n  );\n}\n\n/**\n * This is where we'll set up the board for an upcoming game\n */\n\nconst useBoardStyles = makeStyles({\n  root: {\n    padding: \"1rem\",\n    maxWidth: \"350px\",\n    margin: \"1rem\",\n    \"& > *:not(:first-child)\": {\n      marginTop: \"1rem\",\n    },\n  },\n});\n\nfunction BoardSetup() {\n  // hooks\n\n  const [games, setGames] = useState<Game[]>([]);\n  const [dexes, setDexes] = useState<Pokedex[]>([]);\n\n  const { state, dispatch } = useContext(AllTheFuckingStateCtx);\n  const getter = useContext(PokeGetterContext);\n\n  const styles = useBoardStyles();\n\n  // handlers\n\n  const handleNameChange = (event: ChangeEvent<HTMLInputElement>) => {\n    const name = event.target.value;\n    dispatch({ type: \"setBoardName\", payload: { name } });\n  };\n\n  const handleColumnChange = (event: ChangeEvent<HTMLInputElement>) => {\n    const columns = Number(event.target.value);\n    dispatch({ type: \"setBoardColumns\", payload: { columns } });\n  };\n\n  const handleGameChange = (game: Game) => {\n    dispatch({ type: \"setBoardGame\", payload: game });\n  };\n\n  const handlePokedexChange = (dex: Pokedex) => {\n    dispatch({ type: \"setBoardPokedex\", payload: dex });\n  };\n\n  // fetch state\n\n  useEffect(() => {\n    const fetch = async () => {\n      const games = await getter.getAllGames();\n      setGames(games);\n    };\n    fetch();\n  }, [getter]);\n\n  // useEffect(() => {\n  //   const fetch = async () => {\n  //     const pokes = await getter.getPokemonByGeneration(state.board.generation);\n  //     dispatch({ type: \"setBoardPokemon\", payload: pokes });\n  //   };\n  //   fetch();\n  // }, [getter, dispatch, state.board.generation]);\n\n  useEffect(() => {\n    const fetch = async () => {\n      const dexes = await getter.getPokedexByGame(state.board.game);\n      setDexes(dexes);\n    };\n    fetch();\n  }, [getter, dispatch, state.board.game]);\n\n  useEffect(() => {\n    const fetch = async () => {\n      const pokemon = await getter.getPokemonByPokedex(state.board.pokedex);\n      dispatch({ type: \"setBoardPokemon\", payload: pokemon });\n    };\n    fetch();\n  }, [getter, dispatch, state.board.pokedex]);\n\n  // render\n\n  return (\n    <Grid container>\n      <Grid container item xs={2}>\n        <Paper component=\"form\" className={styles.root}>\n          <TextField\n            fullWidth\n            label=\"Board Name\"\n            onChange={handleNameChange}\n            value={state.board.name}\n          />\n          <FormControl fullWidth>\n            <InputLabel htmlFor=\"column-input\">Columns</InputLabel>\n            <Input\n              id=\"column-input\"\n              type=\"number\"\n              onChange={handleColumnChange}\n              value={state.board.columns}\n            />\n          </FormControl>\n          <BetterSelect\n            id=\"game-select\"\n            label=\"Game\"\n            fullWidth\n            data={games}\n            value={state.board.game}\n            getDisplayValue={(d) => d.name}\n            getKeyValue={(d) => d.name}\n            getValue={(d) => d.id}\n            onChange={handleGameChange}\n          />\n          <BetterSelect\n            id=\"pokedex-select\"\n            label=\"Pokedex\"\n            fullWidth\n            data={dexes}\n            value={state.board.pokedex}\n            getDisplayValue={(d) => d.name}\n            getKeyValue={(d) => d.name}\n            getValue={(d) => d.id}\n            onChange={handlePokedexChange}\n          />\n        </Paper>\n      </Grid>\n      <Grid container item xs={10}>\n        <BoardContainer>\n          <Board\n            columns={state.board.columns}\n            items={state.board.pokemon}\n            renderCell={(item) => (\n              <Cell key={item.name} variant=\"unknown\">\n                <img src={item.artworkUrl} alt={item.name} />\n              </Cell>\n            )}\n          />\n        </BoardContainer>\n      </Grid>\n    </Grid>\n  );\n}\n\nexport function LandingPage() {\n  const { state } = useContext(AllTheFuckingStateCtx);\n  if (state.users.player) {\n    return <BoardSetup />;\n  }\n  return <CreateUser />;\n}\n","import { AllTheFuckingStateProvider } from \"./AllTheFuckingState\";\nimport { PokeGetterProvider } from \"./PokeGetterContext\";\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\n\nimport \"./App.css\";\nimport { LandingPage } from \"./LandingPage\";\n\n/**\n * Let's start thinking about the \"App State\". These will be the various\n * different phases of using this application. Each phase could probably\n * be considered a mini-application\n *\n * 1. Setup - This is where you set up the board, establishing the shape\n * of the board and the order the pokemon appear in\n *\n * 2. Connection - Once the board is configured, we'll try to connect to\n * another instance that we can pass that data along to. Maybe this could\n * happen in the background of other phases?\n *\n * 3. Game - This probably consists of several sub-phases, such as ship\n * placement and actual play\n *\n * 4. PostGame - After a player wins, what happens? Do we just return to\n * the main phase or give people a chance to do another round?\n */\nfunction App() {\n  return (\n    // <WebRTCProvider>\n    //   <SetupProvider>\n    //     <Connector />\n    //     <Loader />\n    //   </SetupProvider>\n    // </WebRTCProvider>\n    <AllTheFuckingStateProvider>\n      <PokeGetterProvider lang=\"en\">\n        {/**\n         * @TODO - instead of hard-coding this, it might be better\n         * to do some fancy logic to determine what the base-url\n         * actually is. This way, localhost:3000/ and reccanti.github.io/ss-anne\n         * would both work\n         *\n         * ~reccanti 6/22/2021\n         */}\n        <Router basename=\"/ss-anne\">\n          <Switch>\n            <Route exact path=\"/\">\n              <LandingPage />\n            </Route>\n          </Switch>\n        </Router>\n      </PokeGetterProvider>\n    </AllTheFuckingStateProvider>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport { CssBaseline, StylesProvider } from \"@material-ui/core\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <StylesProvider>\n      <CssBaseline />\n      <App />\n    </StylesProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}